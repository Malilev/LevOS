# LevOS 2.0 - Claude Code Instructions

## Git Rules

**NEVER push or commit files from the `do not push/` folder.**

This folder contains private/draft materials that should not be in the repository.

## Project Structure

- `index.html` - Main application file (React + Tailwind)
- `do not push/` - Private files, DO NOT COMMIT

## Scenario Timing

- 1st in queue: arrive by 8:30-8:40
- 2nd in queue: arrive by 10:00
- 3rd in queue: arrive by 12:00 (call to confirm! might be 15:00)
- 4th+ in queue: arrive by 15:00

---

## Calendar Grid Architecture

**ВАЖНО: Не менять архитектуру сетки без крайней необходимости!**

### Временной диапазон

- **Начало**: 06:00 (hour = 6)
- **Конец**: 06:00 следующего дня (hour = 30)
- **Всего**: 24 часа = 48 слотов по 30 мин + 1 финальный = 49 слотов

### Система часов (hour)

| Реальное время | Internal hour | Описание |
|----------------|---------------|----------|
| 06:00 - 23:30  | 6 - 23.5      | Дневные часы |
| 00:00 (полночь)| 24            | isMidnight: true |
| 00:30 - 05:30  | 24.5 - 29.5   | isNight: true |
| 06:00 след.дня | 30            | Конец календаря |

### TIME_SLOTS структура

```javascript
TIME_SLOTS = [
  { hour: 6, label: '06', isHalf: false },
  { hour: 6.5, label: '', isHalf: true },
  // ... 06:00-23:30
  { hour: 24, label: '00', isHalf: false, isMidnight: true },
  { hour: 24.5, label: '', isHalf: true, isNight: true },
  // ... 00:00-06:00
  { hour: 30, label: '06', isHalf: false, isNight: true }
]
// Всего 49 слотов
```

### CSS Layout (sticky, без JS scroll sync)

```jsx
<div className="overflow-auto">           {/* Единый скроллируемый контейнер */}
  <div className="flex min-w-max">
    <div className="sticky left-0 z-20">  {/* Время - прилипает слева */}
      <div className="h-[52px] sticky top-0 z-30">  {/* Угол */}
      {TIME_SLOTS.map(...)}               {/* Слоты времени */}
    </div>
    <div className="flex">                {/* Колонки дней */}
      <DayColumn>
        <div className="sticky top-0">    {/* Header дня - 52px */}
        <div className="relative">        {/* Контейнер блоков */}
          <div className="bg-indigo-950/40 pointer-events-none" /> {/* Ночной фон */}
          {TIME_SLOTS.map(...)}           {/* Кликабельные слоты */}
          {schedule.map(...)}             {/* Блоки (absolute) */}
        </div>
      </DayColumn>
    </div>
  </div>
</div>
```

### Правила сетки

1. **Только CSS sticky** - никакого JS для синхронизации скролла
2. **SLOT_HEIGHT = 18px** - высота одного 30-мин слота
3. **Блоки absolute** внутри relative контейнера
4. **Ночной фон** должен иметь `pointer-events-none` чтобы не блокировать клики
5. **Header дня** = sticky top-0, высота 52px
6. **Время слева** = sticky left-0, z-index 20

---

## Блоки (Blocks)

### Структура блока в schedule

```javascript
{
  id: 'OP1-1234567890',      // Уникальный ID
  blockId: 'OP1',            // Тип блока (ключ в blocks)
  startHour: 9,              // Час начала (6-30)
  duration: 90,              // Длительность в минутах
  auto: false                // true = автогенерированный блок
}
```

### Позиционирование блока

```javascript
const startIdx = TIME_SLOTS.findIndex(s => s.hour === item.startHour);
const top = startIdx * SLOT_HEIGHT;
const height = (item.duration / 30) * SLOT_HEIGHT - 1;
```

### Функции управления блоками

| Функция | Описание | Ограничения |
|---------|----------|-------------|
| `placeBlock(dateKey, hour)` | Поставить выбранный блок | ОП только до 21:00 |
| `moveBlock(toDateKey, newHour)` | Переместить блок | ОП только до 21:00 |
| `shiftBlock(dateKey, blockId, deltaHours)` | Сдвинуть ±30 мин | hour 6-30, ОП до 21:00 |
| `resizeBlock(dateKey, blockId, delta)` | Изменить размер ±30 мин | minDur - maxDur |
| `removeBlock(dateKey, blockId)` | Удалить блок | Удаляет auto-блоки для ОП |

### UI кнопки в блоке

- **↑↓** - сдвиг на ±30 мин (shiftBlock)
- **−+** - изменение размера (resizeBlock)
- **×** - удаление (removeBlock)
- **Клик на блок** - режим перемещения (movingBlock)

### Перемещение блоков (Drag & Drop + Click)

**Два режима перемещения:**
1. **Click-to-move** (movingBlock) — клик на блок, затем клик на слот
2. **Drag & Drop** (draggingBlock) — перетащить блок на новое место

**State:**
```javascript
const [movingBlock, setMovingBlock] = useState(null);    // { id, dateKey }
const [draggingBlock, setDraggingBlock] = useState(null); // { id, dateKey, blockId }
const dragDataRef = useRef(null);  // Ref для данных — решает timing issue
```

**Важно: useRef для drag data**

HTML5 Drag & Drop имеет проблему: `onDragEnd` может сработать раньше `onDrop`, очищая state до того, как drop handler его прочитает. Решение — хранить данные в `useRef`:

```javascript
const handleDragStart = (e, id, dateKey, blockId) => {
  dragDataRef.current = { id, dateKey, blockId };  // Сохраняем в ref
  setDraggingBlock({ id, dateKey, blockId });
};

const handleDrop = (toDateKey, newHour) => {
  const dragData = dragDataRef.current;  // Читаем из ref, не из state
  if (!dragData) return;
  // ... логика перемещения
  dragDataRef.current = null;
};

const handleDragEnd = () => {
  dragDataRef.current = null;
  setDraggingBlock(null);
};
```

**Визуальная обратная связь:**
- `opacity: 0.5` — блок выбран для перемещения (movingBlock) или перетаскивается (draggingBlock)
- `ring-2 ring-yellow-400` — click-to-move режим
- `ring-2 ring-white` — drag режим
- `pointerEvents: 'none'` при drag — позволяет drop на слоты под блоком

**Атрибуты блока:**
```jsx
<div
  draggable={!item.auto}
  onDragStart={(e) => handleDragStart(e, item.id, dateKey, item.blockId)}
  onDragEnd={handleDragEnd}
  onClick={() => setMovingBlock(isMoving ? null : { id, dateKey })}
  style={{
    opacity: (isDragging || isMoving) ? 0.5 : 1,
    pointerEvents: isDragging ? 'none' : 'auto'
  }}
>
```

**Слот принимает drop:**
```jsx
<div
  onDragOver={(e) => e.preventDefault()}
  onDrop={() => handleDrop(dateKey, slot.hour)}
  onClick={() => {
    if (movingBlock) moveBlock(dateKey, slot.hour);
    else if (selectedBlock) placeBlock(dateKey, slot.hour);
  }}
>
```

---

## Блок сна (SLEEP)

### Особая логика

1. **Начинается ночью** (hour >= 24, т.е. после полуночи)
2. **Обрезается на hour 30** (06:00 следующего дня)
3. **Overflow в следующий день** - показывается сверху следующей колонки

### Пример: сон 03:00 → 11:00 (8 часов)

**Понедельник (startHour: 27, duration: 480):**
- Отображается: 03:00 → 06:00 (обрезан)
- displayDuration = (30 - 27) * 60 = 180 мин

**Вторник (overflow):**
- startHour: 6 (верх календаря)
- duration: (11 - 6) * 60 = 300 мин
- Пунктирная граница сверху
- opacity: 0.7

### Код обрезки

```javascript
// В текущем дне
if (isSleep && item.startHour >= 24) {
  const endHour = item.startHour + item.duration / 60;
  if (endHour > 30) {
    displayDuration = (30 - item.startHour) * 60;
  }
}

// Overflow в следующем дне
const endHourNextDay = sleepBlock.startHour - 24 + sleepDurationHours;
if (endHourNextDay > 6) {
  overflowDuration = (endHourNextDay - 6) * 60;
  return { startHour: 6, duration: overflowDuration, isOverflow: true };
}
```

---

## Операции (ОП)

### Автогенерируемые блоки

При добавлении ОП автоматически создаются:
- **ROAD** (дорога) - 25 мин до ОП (если >= 07:00)
- **BUFFER** - 30 мин после ОП
- **FAM** (семья) - 50 мин после буфера (если < 22:00)

### Ограничения ОП

- Нельзя ставить после 21:00
- При перемещении/удалении ОП - auto-блоки пересчитываются

---

## Almazova Calculator Timing

- Остаток текущей операции: 30-60 мин
- Полная операция: 60-120 мин

---

## Важные константы

```javascript
const SLOT_HEIGHT = 18;           // Высота слота в пикселях
const TIME_SLOTS.length = 49;     // Количество слотов
const HEADER_HEIGHT = 52;         // Высота заголовка дня
```

## Debugging tips

1. **Блок не появляется**: проверь startHour в диапазоне 6-30
2. **Клики не работают**: проверь pointer-events-none на фоновых элементах
3. **Скролл сломался**: проверь sticky позиционирование и z-index
4. **Блок уходит за край**: проверь обрезку на hour 30 для ночных блоков
